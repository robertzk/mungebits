<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="description" content="Mungebits is a collection of data preparation functions">

    <title>mungebits (http://github.com/robertzk/mungebits)</title>

    <link rel="stylesheet" media="all" href="stylesheets/rocco.css" />
    <link rel="stylesheet" media="all" href="stylesheets/github-markdown.css" />

    <script src="assets/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>

    <style type="text/css">
      .header {
        position: fixed;
        top: 0px;
        width: 100%;
        background-color: rgba(0, 0, 0, 0.25);
        padding: 10px;
      }
      
      .header a {
        padding-right: 30px;
      }

      .container {
        margin-top: 40px;
      }

      body {
        padding: 0;
        margin: 0;
      }

      div.code-background {
        float: right;
        position: fixed;
        z-index: -1;
        height: 100%;
        background-color: #f8f8ff;
        width: 60%;
        right: 0px;
      }

      div.section {
        clear: both;
        margin: 0; padding: 0;
      }

      div.code {
        float: right;
        width: 60%;
      }

      code.R {
        font-size: 1.2em;
        line-height: 2em;
        margin-top: 0em;
        margin-bottom: -2em;
        padding-top: 0;
        margin-top: -1em;
      }

      code.R > span.spacer {
        position: relative;
      }

      div.code > pre {
        margin: 0;
        padding-left: 2em;
        margin-top: 0;
        margin-bottom: 0;
      }

      div.markdown {
        padding: 1em;
        padding-top: 0;
        background: #fff;
        float: left;
        width: 35%;
      }
    </style>

  </head>

  <body>
    <div class="header">
      <a href="https://github.com/robertzk/rocco">
        <img id="rocco-logo" src="https://img.shields.io/badge/Generated by rocco_v0.2.1.2-%E2%9C%93-blue.svg"/>
      </a>
    </div>
    <div class="container">

      <div class="code-background"></div>

        <div class="section">
          <div class="markdown markdown-body">
            <h1>column_transformation.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Pure column transformations.
#'
#' A mungebit which affects multiple columns identically and independently
#' can be abstracted into a column transformation. This function allows one
#' to specify what happens to an individual column, and the mungebit will be
#' the resulting column transformation applied to an arbitrary combination of
#' columns.
#'
#' @param transformation a function. The only argument should be the original
#'    column.
#' @param mutating a logical. Announces whether the transformation passed in
#'    attempts to maintain state between prediction and training runs using
#'    the "inputs" global. 
#' @param named a logical. Whether or not the transformation should be passed
#'    an atomic vector, or a list of length 1 whose single element is given
#'    the same name as the column currently being processed.
#' @return a function which takes a data.frame and a vector of columns and
#'    applies the transformation.
#' @seealso \code{\link{multi_column_transformation}}
#' @export
#' @examples
#' doubler <- column_transformation(function(x) 2*x)
#' # doubles the Sepal.Length column in the iris dataset
#' doubler(iris, c('Sepal.Length')) 
column_transformation <- function(transformation, mutating = FALSE, named = FALSE) {
  force(transformation); force(mutating); force(named)
  invisible(structure(function(dataframe, input_cols = colnames(dataframe), ...) {
    # The fastest way to do this. The alternatives are provided in the comment below
    assign("*tmp.fn.left.by.mungebits.library*",
           transformation, envir = parent.frame())
    if (isdebugged(transformation)) eval.parent(quote(
      debug(`*tmp.fn.left.by.mungebits.library*`)))
    mutating <- mutating # Copy from parent scope to this environment
    named <- named       # Copy from parent scope to this environment
    # if (is.logical(cols)) cols <- which(cols)

    # During prediction, always use same column names as during training
    # TODO: Clean this up
    force(input_cols)
    if (eval.parent(quote(!(exists('inputs') && '*colnames*' %in% names(inputs))))) {
      # Only calculate standard_cols when necessary.
      standard_cols <- intersect(colnames(dataframe),
                                 standard_column_format(input_cols, dataframe))
    }

    invisible(eval(substitute({
      cols <-
        if (exists('inputs') && !'*colnames*' %in% names(inputs))
          inputs$`*colnames*` <<- standard_cols
        else if (exists('inputs') && '*colnames*' %in% names(inputs))
          inputs$`*colnames*`
        else standard_cols

      # Trick to make assignment incredibly fast. Could screw up the
      # data.frame if the function is interrupted, however.
      class(dataframe) <- 'list'
      on.exit(class(dataframe) <- 'data.frame')

      if (!mutating) {
        debug_flag <- isdebugged(`*tmp.fn.left.by.mungebits.library*`)
        prev_environment <- environment(`*tmp.fn.left.by.mungebits.library*`)
        environment(`*tmp.fn.left.by.mungebits.library*`) <- environment()
        if (debug_flag) debug(`*tmp.fn.left.by.mungebits.library*`)
        if (named)
          dataframe[cols] <- lapply(cols, function(colname) {
            `*tmp.fn.left.by.mungebits.library*`(dataframe[colname], ...)
          })
        else 
          dataframe[cols] <- lapply(dataframe[cols], 
            `*tmp.fn.left.by.mungebits.library*`, ...)

        environment(`*tmp.fn.left.by.mungebits.library*`) <- prev_environment
      } else {
        # We must now be surgically precise. The transformation function
        # is attempting to store values in "inputs" using inputs <<- ...
        # However, we would like to allow different values for different
        # columns (for example, a mean imputer needs to remember the mean
        # for each column separately). Therefore, we set an "inputs" variable
        # locally and re-assign the scope of the transformation so that the <<-
        # operator modifies this "inputs" rather than the one in a parent
        # scope (like in a mungebit). Afterwards, we exploit the fact that the
        # <<- operator never modifies local scope using
        #   inputs[[column_name]] <<- inputs
        dataframe[cols] <- lapply(cols, function(column_name) {
          # If this is a prediction run and inputs already exists for this
          # column, use that, otherwise use NULL
          inputs <- if (exists('inputs') &&
                        column_name %in% names(inputs)) inputs[[column_name]]
                    else NULL
          trained <- exists('trained') # TODO: (RK) Be more careful with this
          debug_flag <- isdebugged(`*tmp.fn.left.by.mungebits.library*`)
          # Ensure transformation has access to "inputs"
          prev_environment <- environment(`*tmp.fn.left.by.mungebits.library*`)
          environment(`*tmp.fn.left.by.mungebits.library*`) <- environment()

          if (debug_flag) debug(`*tmp.fn.left.by.mungebits.library*`)
          column <- `*tmp.fn.left.by.mungebits.library*`(
            if (named) dataframe[column_name] else dataframe[[column_name]], ...)
          if (!is.null(inputs)) {
            # The <<- operator never modifies local scope so that left "inputs"
            # refers to the parent.frame() whereas the right "inputs" refers
            # to the one in local scope. The end result is that if the column
            # names were, e.g., c('age', 'height'), the "inputs" in the parent
            # scope would end up as a list with an $age and $height value.
            inputs[[column_name]] <<- inputs
          }

          environment(`*tmp.fn.left.by.mungebits.library*`) <- prev_environment
          column
        })
      }
      # Slightly slower is:
      # for(i in cols) dataframe[[i]] <-
      #   `*tmp.fn.left.by.mungebits.library*`(dataframe[[i]], ...)
      dataframe[cols[
        vapply(cols,
               function(x) is.null(dataframe[[x]]),
               logical(1))
      ]] <- NULL

      class(dataframe) <- 'data.frame'
      NULL
    }), envir = parent.frame()))
  }, class = c('transformation', 'function'), named = named, mutating = mutating))
}

# Possible column transformations:
# 1: function(dataframe, col) { dataframe[col] <- 2*dataframe[col]; dataframe }
# 2: function(dataframe, col) { eval(substitute(dataframe[col] <- 2*dataframe[col]), envir = parent.frame()) }
# 3: function(dataframe, col) { class(dataframe) <- 'list'; for(colname in col) dataframe[[colname]] <- 2*dataframe[[colname]]; class(dataframe) <- 'data.frame'; dataframe }
# 4: function(dataframe, col) { eval(substitute({ class(dataframe) <- 'list'; for(colname in col) dataframe[[col]] <- 2*dataframe[[col]]; class(dataframe) <- 'data.frame'; dataframe }), envir = parent.frame()) }
# 5: The method above for dynamic lambdas
# An extra rm function after the assign increases runtime by 75% with frequent application.
# The fifth option is the fastest.


##' @export
#CT <- column_transformation
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>helpers.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">if (!exists("%||%")) `%||%` <- function(x, y) { if (is.null(x)) y else x }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>multi_column_transformation.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Old-to-new column mapping transformation
#'
#' A mungebit which does not affect any existing columns, but can transform
#' other columns into new columns, or affect multiple columns simultaneously
#' as functions of each other.
#'
#' @param transformation a function. The arguments will be the ordered columns
#'    selected from the dataframe when the transformation is performed (see
#'    examples). One has to be careful to return an atomic vector if the
#'    result is 1-dimensional, and a list otherwise.
#' @return a function which takes a data.frame, input columns, and output
#'    columns, the latter two of which specify the domain and range of the
#'    transformation (see examples).
#' @seealso \code{\link{column_transformation}}
#' @export
#' @examples
#' perimeter <- multi_column_transformation(function(x, y) 2*x + 2*y)
#' perimeter(iris, c('Sepal.Length', 'Sepal.Width'), 'Sepal.Perimeter')
#'
#' multiplier <- multi_column_transformation(function(x, y) x*y)
#' multiplier(iris, c('Sepal.Length', 'Sepal.Width'), 'Sepal.Area')
#'
#' property_generator <- multi_column_transformation(
#'    function(x, y) list(2*x + 2*y, x*y))
#' property_generator(iris, c('Sepal.Length', 'Sepal.Width'),
#'    c('Sepal.Perimeter', 'Sepal.Area'))
#'
#' swapper <- multi_column_transformation(function(x, y) list(y, x))
#' swapper(iris, c('Sepal.Length', 'Sepal.Width'),
#'   c('Sepal.Width', 'Sepal.Length'))
#'
#' column_remover <- multi_column_transformation(function(...) NULL)
#' column_remover(iris, c('Sepal.Length', 'Sepal.Width'))
#'
#' scaling_fun <- function(...) {
#'   args <- list(...)
#'   const <- args[[length(args)]]
#'   args <- head(args, -1)
#'   if (length(args) == 1) args[[1]] * const
#'   else lapply(args, function(col) col * const)
#' }
#' scaler <- multi_column_transformation(scaling_fun)
#' # scale Sepal.Length and Sepal.Width by two
#' scaler(iris, c('Sepal.Length', 'Sepal.Width'), , 2)
#' scaler(iris[c('Petal.Length', 'Petal.Width')], , , 2)
#' # Note the missing second and third arguments.
multi_column_transformation <- function(transformation) {
  invisible(structure(function(dataframe, input_cols = colnames(dataframe),
           output_cols = input_cols, ...) {
    # The fastest way to do this. The alternative is to use pass by value
    # or replace list subset assignment below with mapply.
    assign("*tmp.fn.left.by.mungebits.library*",
           transformation, envir = parent.frame())

    input_cols <- force(input_cols)
    if (is.logical(input_cols)) input_cols <- which(input_cols)
    output_cols <- force(output_cols)
    if (is.logical(output_cols)) output_cols <- which(output_cols)

    dataframe <- substitute(dataframe)
    invisible(eval(substitute({
      # Trick to make assignment incredibly fast. Could screw up the
      # data.frame if the function is interrupted, however.
      class(dataframe) <- 'list'
      on.exit(class(dataframe) <- 'data.frame')

      # Unfortunately, due to the wrapped substitute causing scoping issues,
      # the clever
      #   (if (length(output_cols) == 1) `[[<-` else `[<-`)(dataframe, ...)
      # does not work here.
      if (length(output_cols) == 1)
        dataframe[[output_cols]] <-
          do.call(`*tmp.fn.left.by.mungebits.library*`,
                  append(unname(dataframe[input_cols]), list(...)))
      else
        dataframe[output_cols] <-
          do.call(`*tmp.fn.left.by.mungebits.library*`,
                  append(unname(dataframe[input_cols]), list(...)))

      #for(col in colnames(iris2)[vapply(iris2[1,], is.null, logical(1))]) iris2[[col]] <- NULL 
      # Keeping some alternative code for now:
      # Remove any columns that were set to NULL explicitly
      #which(vapply(output_cols, function(x) is.null(dataframe[[x]]), logical(1))) 
      # dataframe[which(vapply(output_cols, function(x) is.null(dataframe[[x]]), logical(1))) %||% integer(0)] <- NULL
      dataframe[seq_along(dataframe)[
        vapply(seq_along(dataframe),
               function(x) is.null(dataframe[[x]]),
               logical(1))
      ]] <- NULL
      #dataframe[output_cols[
      #  vapply(intersect(output_cols, names(dataframe)),
      #         function(x) is.null(dataframe[[x]]),
      #         logical(1))
      #]] <- NULL

      class(dataframe) <- 'data.frame'
      NULL
    }), envir = parent.frame()))
  }, class = c('multiColumnTransformation', 'transformation', 'function')
  # TODO: named = named, mutating = mutating)
  ))
}

##' @export
# MCT <- multi_column_transformation
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>munge.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' General-purpose data munging
#'
#' One can use \code{munge} to take a \code{data.frame}, apply a given set
#' of transformations, and persistently store the operations on
#' the \code{data.frame}, ready to run on a future \code{data.frame}.
#'
#' @param dataframe a data set to operate on.
#' @param ... usually a list specifying the necessary operations (see
#'    examples).
#' @param stagerunner logical or list. Whether to run the munge procedure or
#'    return the parametrizing stageRunner object (see package stagerunner).
#'    If a list, one can specify \code{remember = TRUE} to pass to the
#'    stageRunner initializer.
#' @param train_only logical. Whether or not to leave the \code{trained}
#'    parameter on each mungebit to \code{TRUE} or \code{FALSE} accordingly.
#'    For example, if \code{stagerunner = TRUE} and we are planning to re-use
#'    the stagerunner for prediction, it makes sense to leave the mungebits
#'    untrained. (Note that this will prevent one from being able to run the
#'    predict functions!)
#' @return data.frame that has had the specified operations applied to it,
#'    along with an additional property \code{mungepieces} that records
#'    the history of applied functions. These can be used to reproduce
#'    the transformations on e.g., a dataset that needs to have a
#'    prediction run.
#' @export
#' @examples
#' \dontrun{
#' iris2 <- munge(iris,
#'   list(column_transformation(function(x) 2 * x), 'Sepal.Length'))
#' stopifnot(iris2[['Sepal.Length']] == iris[['Sepal.Length']] * 2)
#'
#' iris2 <- munge(iris,
#'    # train function & predict function
#'    list(c(column_transformation(function(x) 2 * x),
#'         column_transformation(function(x) 3 * x)),
#'    # arguments to pass to transformation, i.e. column names in this case
#'    'Sepal.Length'))
#' stopifnot(iris2[['Sepal.Length']] == iris[['Sepal.Length']] * 2)
#' iris3 <- munge(iris, attr(iris2, 'mungepieces'))
#' # used transformations ("mungepieces") stored on iris2 and apply to iris3.
#' # They will remember that they've been trained already and run the
#' # prediction routine instead of the training routine. Note the above is
#' # also equivalent to the shortcut: munge(iris, iris2)
#' stopifnot(iris3[['Sepal.Length']] == iris[['Sepal.Length']] * 3)
#' }
munge <- function(dataframe, ..., stagerunner = FALSE, train_only = FALSE) {
  mungepieces <- list(...)
  if (length(mungepieces) == 0) return(dataframe)

  plane <- if (is.environment(dataframe)) dataframe else mungeplane(dataframe)

  if (is.data.frame(mungepieces[[1]]))
    mungepieces[[1]] <- attr(mungepieces[[1]], 'mungepieces')
  else if (is(mungepieces[[1]], 'tundraContainer'))
    mungepieces[[1]] <- mungepieces[[1]]$munge_procedure

  # If mungepieces[[1]] is of the form
  # list(list|mungepiece|function, list|mungepiece|function, ...)
  # just put it into mungepieces. This is so munge can be called as either
  # munge(dataframe, list(...)) or munge(dataframe, ...)
  if (length(mungepieces) == 1 && is.list(mungepieces[[1]]) &&
      all(unlist(lapply(mungepieces[[1]],
        function(x) {
          is.mungepiece(x) || is.mungebit(x) ||
          is.list(x) || is.function(x) || 
          is(x, 'stageRunner') })))) {
      mungepieces <- mungepieces[[1]]
  }

  mungepieces <- lapply(mungepieces, parse_mungepiece,
                        train_only = !identical(train_only, FALSE))

  # order matters, do not parallelize!
  stages <- lapply(mungepieces, function(piece) {
    force(piece);
    if (is(piece, 'stageRunner') || is.function(piece)) { piece }
    else { function(env) { piece$run(env) } }
  })

  stages <- append(stages, list(function(env) {
    # For now, store the mungepieces on the dataframe
    # When attaching mungepieces, only append to the dataframe the things that are actually mungepieces.
    # TODO: (RK) VERY URGENT BUGFIX NEEDED: Correctly sort the mungepieces when using
    # nested runners.

    atomic_mungepieces <- Filter(function(x) { is(x, "mungepiece") }, mungepieces)
    if (length(atomic_mungepieces) > 0) {
      attr(env$data, 'mungepieces') <-
        append(attr(env$data, 'mungepieces'), atomic_mungepieces)
    }
  }))
  names(stages)[length(stages)] <- "(Internal) Store munge procedure on dataframe"

  if (!missing(stagerunner) && !identical(stagerunner, FALSE)) require(stagerunner)
  remember <- if ('remember' %in% names(stagerunner)) stagerunner$remember else FALSE
  runner <- stageRunner$new(as.environment(plane), stages, remember = remember)

  if (!missing(stagerunner) && !identical(stagerunner, FALSE)) runner
  else {
    runner$run()
    plane$data
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>mungebit.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Constructor for mungebit class.
#'
#' Mungebits are atomic data transformations of a data.frame that,
#' loosely speaking, aim to modify "one thing" about a variable or
#' collection of variables. This is pretty loosely defined, but examples
#' include dropping variables, mapping values, discretization, etc.
#'
#' @docType class
#' @rdname mungebit
#' @param train_fn function. This specifies the behavior to perform
#'    on the dataset when preparing for model training. A value of NULL
#'    specifies that there should be no training step.
#' @param predict_fn function. This specifies the behavior to perform
#'    on the dataset when preparing for model prediction. A value of NULL
#'    specifies that there should be no prediction step.
#' @param enforce_train logical. Whether or not to flitch the trained flag
#'    during runtime.
#' @seealso \code{\link{mungepiece}}
#' @examples
#' \dontrun{
#' mp <- mungeplane(iris)
#' mb <- mungebit(column_transformation(function(col, scale = NULL) {
#'   if ('scale' %in% names(inputs))
#'     cat("Column scaled by ", inputs$scale, "\n")
#'   else inputs$scale <<- scale
#'   col * inputs$scale
#' }))
#' mb$run(mp, 'Sepal.Length', 2)
#' # mp$data now contains a copy of iris w/ the Sepal.Length column doubled
#' head(mp$data[[1]] / iris[[1]])
#' # > [1] 2 2 2 2 2 2
#' mb$run(mp, 'Sepal.Length')
#' # > Column scaled by 2
#' head(mp$data[[1]] / iris[[1]])
#' # > [1] 4 4 4 4 4 4 
#' }
#' 
mungebit__initialize <- function(train_fn = function(x) x,
                                  predict_fn = train_fn, enforce_train = TRUE) {
  train_function <<- train_fn
  predict_function <<- predict_fn

  inputs <<- list()
  trained <<- FALSE
  enforce_train <<- enforce_train
}

#' Run a mungebit.
#' 
#' Imagine flipping a switch on a set of train tracks. A mungebit
#' behaves like this: once the \code{trained} switch is flipped,
#' it can only run the \code{predict_fn}, otherwise it will
#' run the \code{train_fn}.
#'
#' @rdname mungebit
#' @param mungeplane mungeplane. Essentially an environment containing
#'   a \code{data} variable.
#' @param ... additional arguments to the mungebit's \code{train_fn} or
#'   \code{predict_fn}.
#' @seealso \code{\link{mungebit__initialize}}
mungebit__run <- function(mungeplane, ...) {
  # We cannot use, e.g., .self$train(mungeplane, ...),
  # because we must force the ... to get evaluated due to
  # non-standard evaluation in the train and predict methods.
  do.call(if (!trained) .self$train else .self$predict,
          list(mungeplane, ...))
  invisible()
}

#' Run the predict function on a mungebit.
#'
#' @rdname mungebit
#' @seealso \code{\link{mungebit__run}}, \code{\link{mungebit__initialize}}
mungebit__predict <- function(mungeplane, ...) {
  if (!is.null(predict_function)) {
    original_env <- environment(predict_function)
    inject_inputs(predict_function)
    on.exit(environment(predict_function) <<- original_env)

    predict_function(mungeplane$data, ...) 
  }
  invisible(TRUE)
}

#' Run the train function on a mungebit.
#'
#' @rdname mungebit
#' @seealso \code{\link{mungebit__run}}, \code{\link{mungebit__initialize}}
mungebit__train <- function(mungeplane, ...) {
  if (!is.null(train_function)) {
    original_env <- environment(train_function)
    inject_inputs(train_function)
    on.exit(environment(train_function) <<- original_env)

    train_function(mungeplane$data, ...) 

    # TODO: Oh no. :( Sometimes inputs is being set and sometimes
    # environment(train_function)$inputs is being set--I think this
    # has to do with changing the environment of the function that's
    # running. How do we get around this? This seems incredibly messy.
    inputs <<-
      if (length(tmp <- environment(train_function)$inputs) > 0) tmp
      else inputs
  }
  if (enforce_train) trained <<- TRUE
  invisible(TRUE)
}

#' This class is intended to abstract the idea of separate data preparation
#' during training versus prediction.
#'
#' @export
mungebit <- setRefClass('mungebit',
  fields = list(train_function = 'ANY',
                predict_function = 'ANY',
                inputs = 'list',
                trained = 'logical',
                enforce_train = 'logical'),
  methods = list(
    initialize = mungebits:::mungebit__initialize,
    run        = mungebits:::mungebit__run,
    predict    = mungebits:::mungebit__predict,
    train      = mungebits:::mungebit__train
  )
)

#' @export
is.mungebit <- function(x) inherits(x, 'mungebit')

#' Inject a parent environment that has only an inputs key so that
#' things like \code{inputs <<- 'foo'} work.
#'
#' @param fn function. The function on which to inject.
inject_inputs <- function(fn) {
  eval.parent(substitute({
    run_env <- new.env(parent = environment(fn))
    run_env$inputs <- inputs
    debug_flag <- isdebugged(fn)
    environment(fn) <<- run_env
    # Restore debugging if it was enabled.
    if (debug_flag) debug(fn)
  }))
}

# S3 class...uglier way to do it
# mungebit <- function(train_function,
#                      predict_function = train_function, 
#                      modifies.column = TRUE,
#                      modifies.row = FALSE,
#                      modifies.column.dimension = FALSE,
#                      modifies.row.dimension = FALSE) {
#   function(...) {
#     arguments <- as.list(...)
#     # function(df) {
#     #   do.call(mungebit_function, arguments)
#   }
# }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>mungebits-package.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Mungebits is a collection of data processing snippets for the
#' munger library.
#'
#'
#' @name mungebits
#' @import stagerunner
#' @docType package
NULL</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>mungepiece.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">setClassUnion('listOrNull', c('list', 'NULL'))
#' Mungepieces are mungebits that have had their arguments cached
#' (with the exception of the first, the data.frame).
#'
#' A mungepiece allows one to fix the arguments to a mungebit
#' (such as input and output columns), without yet necessarily
#' specifying the data.frame on which the mungebit operates. In
#' this way, the mungepiece can "pick up" what operations to perform
#' on a to-be-trained dataset, and later what operations to perform
#' on a to-be-predicted dataset, without yet knowing what the data
#' itself is.
#'
#' @docType class
#' @name mungepiece
#' @param bit a mungebit. The mungepiece produced will be a wrapper around
#'    this mungebit that caches the arguments to subsequent calls.
#' @param train_args a list. These will be passed when a mungebit is run
#'    the first time using \code{mungebit$run} or \code{mungebit$train}.
#' @param predict_args a list. These will be passed when a mungebit is run
#'    subsequent times using \code{mungebit$run} or \code{mungebit$predict}.
#' @export
#' @examples
#' \dontrun{
#' doubler <- mungebit(column_transformation(function(x) x * 2))
#' cols <- c('Sepal.Length', 'Petal.Length')
#' mp <- mungepiece(doubler, list(cols))
#' iris2 <- mungeplane(iris)
#' mp$run(iris2)
#' stopifnot(iris2$data[cols] == 2 * iris[cols])
#' }
mungepiece <- setRefClass('mungepiece',
  fields = list(bit = 'mungebit',
                train_args = 'list',
                predict_args = 'listOrNull'),
  methods = list(
    initialize = function(.bit, .train_args = list(), .predict_args = .train_args) {
      if (!is.list(.train_args)) .train_args <- list(.train_args)
      if (!is.list(.predict_args) && !is.null(.predict_args))
        .predict_args <- list(.predict_args)

      stopifnot(is.mungebit(.bit))

      bit <<- .bit
      train_args <<- .train_args
      predict_args <<- .predict_args
    },

    run = function(.mungeplane, ...) {
      method <- if (bit$trained) bit$predict else bit$train
      rest_args <- list_merge(
        if (bit$trained) predict_args %||% train_args
        else train_args, list(...))
      do.call(method, append(list(.mungeplane), rest_args))
    }
  )
)

is.mungepiece <- function(x) inherits(x, 'mungepiece')

#' @export
list_merge <- function(list1, list2) {
  for (i in seq_along(list2)) {
    name <- names(list2)[i]
    if (!identical(name, NULL) && !identical(name, "")) list1[[name]] <- list2[[i]]
    else list1 <- append(list1, list(list2[[i]]))
  }
  list1
}
    
# S3 definition... uglier I think, since you need to knwo the calling convention
#mungepiece <- function(bit, train_args, predict_args = train_args) {
#  mp <- list()
#  class(mp) <- 'mungepiece'
#
#  stopifnot(is.mungebit(bit), is.list(train_args), is.list(predict_args))
#  attr(mp, 'mungebit') <- bit
#  attr(mp, 'train_args') <- train_args
#  attr(mp, 'predict_args') <- predict_args
#  mp
#}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>mungeplane.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Mungeplane are reference classes wrappers around a dataframe.
#'
#' By exploiting pass-by-reference semantics of reference classes,
#' mungeplanes allow mungebits to manipulate individual columns and rows of
#' dataframes without forcing copy-on-write triggers that would copy the
#' entire dataframe.
#'
#' @name mungeplane
#' @param dataframe a \code{data.frame}. This can also be a list to help with
#'    optimization procedures in mungebit operations that temporarily remove
#'    the \code{data.frame} class to use built-in C replacement functions.
#' @return mungeplane an environment with a "data" object of class "mungeplane"
#' @export
#' @examples
#' \dontrun{
#' mp <- mungeplane(iris)
#' (function(plane) plane$data[[1]] <- 2 * plane$data[[1]])(mp)
#' stopifnot(all.equal(mp$data[[1]], 2 * iris[[1]]))
#' }
mungeplane <- function(dataframe) {
  if (is.environment(dataframe)) plane <- dataframe
  else {
    plane <- new.env(parent = parent.frame()) 
    plane$data <- dataframe
  }
  class(plane) <- 'mungeplane'
  plane
}

is.mungeplane <- function(x) inherits(x, 'mungeplane')


#setClassUnion('listOrDataFrame', c('list', 'data.frame'))
#mungeplane <- setRefClass('mungeplane',
#  fields = list(data = 'listOrDataFrame'),
#  methods = list(
#    initialize = function(dataframe) {
#      data <<- dataframe
#    }
#  )
#)

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>parse_mungepiece.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Translate a list of arguments passed to a mungebit into a mungepiece
#'
#' For example, one can pass a training function, a prediction function,
#' and additional arguments, and the constructed mungepiece will hold
#' these arguments, ready to call the attached mungebit on a given dataframe.
#'
#' @name parse_mungepiece
#' @param args a list. This can be of the formats
#'   \code{list(train_fn, ...)}, \code{list(list(train_fn, predict_fn), ...)},
#'   and \code{list(list(train_fn, ...), list(predict_fn, ...))}. In the first
#'   example, the train and predict function are assumed to be identical. In
#'   the first two examples, the arguments to these functions are assumed to
#'   be identical (for example, if the same kind of filter needs to be applied
#'   to a data set that is about to be trained as to one about to be
#'   predicted). Finally, the last example is the most flexible and allows
#'   different parameters for the training and prediction function,
#'   respectively. The given training and prediction functions are used to
#'   construct a \code{mungebit}, and the resulting \code{mungebit} and 
#'   the remaining arguments are stored in a \code{mungepiece}.
#' @param train_only logical. Whether or not to leave the \code{trained}
#'    parameter on each mungebit to \code{TRUE} or \code{FALSE} accordingly.
#'    For example, if \code{stagerunner = TRUE} and we are planning to re-use
#'    the stagerunner for prediction, it makes sense to leave the mungebits
#'    untrained. (Note that this will prevent one from being able to run the
#'    predict functions!)
#' @return the parsed mungepiece
#' @export
#' @examples
#' \dontrun{
#' doubler <- column_transformation(function(x) x * 2)
#' mp <- parse_mungepiece(list(doubler, 'Sepal.Length')) 
#' iris2 <- mungeplane(iris)
#' mp$run(iris2)
#' stopifnot(all.equal(iris2$data[[1]], 2 * iris[[1]]))
#' 
#' # TODO: Way more examples, unit tests
#' 
#' }
parse_mungepiece <- function(args, train_only = FALSE) {
  if (is.mungepiece(args)) return(args)
  if (is(args, 'stageRunner')) return(args)
  if (is.mungebit(args) || is.function(args)) args <- list(args)
  if (is.mungebit(args[[1]])) {
    mb <- args[[1]]
    mb$enforce_train <- !train_only
    return(mungepiece(mb, args[-1]))
  }
  stopifnot(is.list(args))  
  if (is.list(args) && length(args) == 1 && is.mungepiece(args[[1]]))
    return(args[[1]])

  if (is.list(args[[1]]) && length(args) > 1 && is.list(args[[2]]) &&
      length(args[[1]]) > 0 && is.function(args[[1]][[1]]) &&
      length(args[[2]]) > 0 && is.function(args[[2]][[1]])) {
    # train and predict functions have separate arguments
    # list(list(train_fn, ...), list(predict_fn, ...))
    train_fn <- args[[1]][[1]]
    args[[1]][[1]] <- NULL
    train_args <- args[[1]]
    
    predict_fn <- args[[2]][[1]]
    args[[2]][[1]] <- NULL
    predict_args <- args[[2]]
  } else {
    stopifnot(length(args) > 0)
    if (is.list(args[[1]])) {
      # list(list(train_fn, predict_fn), ...)
      stopifnot(length(args[[1]]) == 2)
      train_fn <- args[[1]][[1]]
      predict_fn <- args[[1]][[2]]
    } else {
      # list(train_fn, ...)
      train_fn <- args[[1]]
      predict_fn <- train_fn
    }
                      
    args[[1]] <- NULL
    train_args <- args
    predict_args <- train_args
  }
  stopifnot((is.function(train_fn) || is.null(train_fn)) && 
            (is.function(predict_fn) || is.null(predict_fn)))
  if (!is.null(train_fn)) class(train_fn) <- 'function'    # Clear triggers
  if (!is.null(predict_fn)) class(predict_fn) <- 'function'

  mungepiece(mungebit(train_fn, predict_fn, enforce_train = !train_only),
             train_args,
             predict_args)
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>print.transformation.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' A convenience method to make printing of transformations more obvious.
#'
#' @param x a \code{transformation}. Either a \code{column_transformation}
#'    or \code{multi_column_transformation}.
#' @param ... additional parameters to print.
#' @export
#' @seealso \code{\link{column_transformation}},
#'      \code{\link{multi_column_transformation}}
print.transformation <- function(x, ...) {
  cat("This is a mungebits transformation as defined in the",
      "syberiaMungebits package.\n")
  labels <- if (identical(attr(x, 'named'), TRUE)) 'named' else c()
  labels <- append(labels, if (identical(attr(x, 'mutating'), TRUE)) 'mutating' else c())
  if (length(labels) > 0) {
    labels <- paste0(labels, collapse = ' and ')
    cat("It is a", labels, "transformation.",
        "For help, see ?column_transformation.\n")
  }
  fn <- environment(x)$transformation
  base::print(fn, ...)
}</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>standard_column_format.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Converts a logical / numeric / character vector or a function
#' into a character vector of column names for a dataframe.
#'
#' If a function is provided, it will be applied to each column of
#' the dataframe and must return a logical; those with resulting value TRUE
#' will be returned as a character vector.
#'
#' @param cols a vector or function. If logical / numeric / character vector,
#'    it will attempt to find those columns matching these values. If \code{cols}
#'    is a function, it will apply this function to each column of the dataframe
#'    and return the names of columns for which it was \code{TRUE}. Additionally,
#'    \code{cols} can be a list of any combination of the above, which will 
#'    require all the conditions to be met.
#' @param dataframe a reference dataframe. Necessary for computing the
#'    column names if a numeric or logical vector is specified for \code{cols}.
#' @export
#' @examples
#' standard_column_format(c(1,5), iris)  # c('Sepal.Length', 'Species')
#' standard_column_format(c(TRUE,FALSE,FALSE,FALSE,TRUE), iris)  # c('Sepal.Length', 'Species')
#' standard_column_format('Sepal.Length', iris)  # 'Sepal.Length'
#' standard_column_format(list(is.numeric, c(1,5)), iris)  # 'Sepal.Length'
#' # TODO: (RK) Explain except()
standard_column_format <- function(cols, dataframe) {
  if (missing(dataframe)) stop('No dataframe provided')
  missingcols <- missing(cols)
  if (missingcols) colnames(dataframe)
  else {
    eval.parent(substitute({
      unexcept <- function(x) {
        class(x) <- setdiff(class(x), 'except')
        x
      }

      process <- function(xcols) {
        Reduce(intersect, lapply(xcols, function(subcols) {
          if (is(subcols, 'except')) {
            unexcepted <- unexcept(subcols)
            if (!is.list(unexcepted)) unexcepted <- list(unexcepted)
            setdiff(colnames(dataframe), process(unexcepted))
          } else if (is.function(subcols)) {
            # Much faster than lapply here.
            colnames(dataframe)[(function() {
              ix <- logical(length(dataframe))
              for (i in seq_along(dataframe)) ix[i] <- subcols(.subset2(dataframe, i))
              ix
            })()]
          }
          else if (is.character(subcols)) force(subcols) 
          else if (is.list(subcols)) process(subcols)
          else colnames(dataframe)[subcols]
        }))
      }

      if (is(cols, 'except')) setdiff(colnames(dataframe), process(list(unexcept(cols))))
      else process(if (is.list(cols)) cols else list(cols))
    }))
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>transformation.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @export
is.transformation <- function(x) inherits(x, 'transformation')</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>utils.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Merge two lists and overwrite latter entries with former entries
#' if names are the same.
#'
#' For example, \code{list_merge(list(a = 1, b = 2), list(b = 3, c = 4))}
#' will be \code{list(a = 1, b = 3, c = 4)}.
#' @param list1 list
#' @param list2 list
#' @return the merged list.
#' @examples
#' stopifnot(identical(list_merge(list(a = 1, b = 2), list(b = 3, c = 4)),
#'                     list(a = 1, b = 3, c = 4)))
#' stopifnot(identical(list_merge(NULL, list(a = 1)), list(a = 1)))
list_merge <- function(list1, list2) {
  list1 <- list1 %||% list()
  # Pre-allocate memory to make this slightly faster.
  list1[Filter(function(x) nchar(x) > 0, names(list2) %||% c())] <- NULL
  for (i in seq_along(list2)) {
    name <- names(list2)[i]
    if (!identical(name, NULL) && !identical(name, "")) list1[[name]] <- list2[[i]]
    else list1 <- append(list1, list(list2[[i]]))
  }
  list1
}

`%||%` <- function(x, y) if (is.null(x)) y else x

#' @export
except <- function(x) {
  class(x) <- c('except', class(x))
  x
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>zzz.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">.onAttach <- function(...) {
}

.onUnload <- function(...) {
}</span></code>
            </pre>
          </div>
        </div>
      <div class="section">
      </div>

    </div>
  </body>
</html>
